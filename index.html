<!DOCTYPE html>
<html>
<head>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>BOI (Bunch Of Ifs)</title>
	<link rel="stylesheet" type="text/css" href="css/chessboard-0.3.0.min.css">
	<script type="text/javascript" src="js/chess.min.js"></script>
	<script type="text/javascript" src="js/jquery-3.3.1.min.js"></script>
	<script type="text/javascript" src="js/chessboard-0.3.0.min.js"></script>
	<style type="text/css">
		body {
			margin: 0;
			padding: 0;
			display: flex;
			justify-content: center;
		}
		#board {
			display: flex;
        	align-items: center;
			margin: 0;
            height: 100vh;
			width: 70vw;
		}
		.white-1e1d7 {
			background: #ffffff;
		}
		.black-3c85d {
			background: #d2d2d2;
		}
	</style>
</head>
<body>
	<div id="board"></div>
</body>
<script type="text/javascript">
    window.addEventListener("resize", function() {
        window.board.resize();
    });
	window.wallpaperPropertyListener = {
		applyUserProperties: function(properties) {
			if(properties.background) {
				let rgb = properties.background.value.split(" ");
				rgb[0] = Math.round(rgb[0] * 255);
				rgb[1] = Math.round(rgb[1] * 255);
				rgb[2] = Math.round(rgb[2] * 255);
				document.body.style.background = "rgb("+rgb[0]+","+rgb[1]+","+rgb[2]+")";
			}

			if(properties.board_width) {
				document.getElementById("board").style.width = properties.board_width.value + "px";
				if(window.board) {
					window.board.resize();
				}
			}

			if(properties.game_speed) {
				window.gameSpeed = parseInt(properties.game_speed.value);
			}

			if(properties.new_game_delay) {
				window.newGameDelay = parseInt(properties.new_game_delay.value);
			}

			if(properties.light_squares) {
				let rgb = properties.light_squares.value.split(" ");
				rgb[0] = Math.round(rgb[0] * 255);
				rgb[1] = Math.round(rgb[1] * 255);
				rgb[2] = Math.round(rgb[2] * 255);
				document.styleSheets[1].cssRules[2].style.background = "rgb("+rgb[0]+","+rgb[1]+","+rgb[2]+")";
			}

			if(properties.dark_squares) {
				let rgb = properties.dark_squares.value.split(" ");
				rgb[0] = Math.round(rgb[0] * 255);
				rgb[1] = Math.round(rgb[1] * 255);
				rgb[2] = Math.round(rgb[2] * 255);
				document.styleSheets[1].cssRules[3].style.background = "rgb("+rgb[0]+","+rgb[1]+","+rgb[2]+")";
			}
		}
	};
    let pieceCost = {
        p: 1, n: 3, b: 3, r: 5, q: 9, k: Infinity
    };

	let boardConfig = {
		showNotation: false,
		position: "start",
		moveSpeed: "fast",
		pieceTheme: 'img/chesspieces/alpha/{piece}.png'
	};

	window.gameSpeed = 250;
	window.newGameDelay = 1;
	window.board = ChessBoard("board", boardConfig);
	window.game = new Chess();
    window.setTimeout(MakePseudoRandomMove, 200);

	function MakePseudoRandomMove() {
		let possibleMoves = window.game.moves({verbose:true});
		if(window.game.game_over() || window.game.in_draw() || possibleMoves.length === 0) {
			return setTimeout(function() {
				game.reset();
				MakePseudoRandomMove();
			}, window.newGameDelay * 1000);
		}

		let move = null;

        //If there is a checkmate, then checkmate
        let foundCheckmate = false;
        for(let i = 0; i < possibleMoves.length; i++) {
            if(possibleMoves[i].san.indexOf("#") >= 0) {
                move = possibleMoves[i];
                foundCheckmate = true;
                break;
            }
        }

        if(!foundCheckmate) {
            //Try to find a most valued free capture
            let possibleFreeCaptures = getFreeCaptures(possibleMoves);
            if(possibleFreeCaptures.length > 0) {
                move = possibleFreeCaptures[Math.floor(Math.random() * possibleFreeCaptures.length)];
            } else {
                //If we don't have a free capture
                //Try to find a valued capture
                let possibleCaptures = getValueCaptures(possibleMoves);
                if(possibleCaptures.length > 0) {
                    move = possibleCaptures[Math.floor(Math.random() * possibleCaptures.length)];
                } else {
                    //If we don't have any good captures
                    //Check if we need to save some piece from capture
                    let attacked = getMostValuedAttackedSquare();
                    let foundEscapeMove = false;
                    if(attacked) {
                        let possibleSafeMoves = getSafeMoves(possibleMoves);
                        for(let i = 0; i < possibleSafeMoves.length; i++) {
                            let m = possibleSafeMoves[i];
                            if(m.from === attacked) {
                                //There is an escape move!
                                foundEscapeMove = true;
                                move = m;
                                break;
                            }
                        }
                    }
                    if(!foundEscapeMove) {
                        //If nothing of value is attacked
                        //Try to find a safe move
                        let possibleSafeMoves = getSafeMoves(possibleMoves);
                        if(possibleSafeMoves.length > 0) {
                            move = possibleSafeMoves[Math.floor(Math.random() * possibleSafeMoves.length)];
                        }
                    }
                }
            }
        }

        //If no checkmate, free capture, value capture
        //Pick random move
        if(!move) {
            move = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
        }

		window.game.move(move);
		//Stop movement animations on a fast timer
		window.board.position(window.game.fen(), window.gameSpeed < 250 ? false : true);
		window.setTimeout(MakePseudoRandomMove, window.gameSpeed);
	}

    function getFreeCaptures(moves) {
        let possibleFreeCaptures = [];
        let maxValue = -Infinity; //We want any free capture at first
        for(let i = 0; i < moves.length; i++) {
            let m = moves[i];
            if(m.captured) {
                let isNotFree = false;
                //Test out capture
                window.game.move(m);
                //Check if are re-captures on that square
                let newPossibleMoves = window.game.moves({verbose:true});
                for(let k = 0; k < newPossibleMoves.length; k++) {
                    let m2 = newPossibleMoves[k];
                    if(m2.captured && m2.to === m.to) {
                        isNotFree = true;
                        break;
                    }
                }
                
                window.game.undo(); //Restore previous position

                if(isNotFree) {
                    continue; //Try next capture
                } else {
                    let value = pieceCost[m.captured];
                    if(value > maxValue) {
                        possibleFreeCaptures = [m];
                        maxValue = value;
                    } else if(value === maxValue) {
                        possibleFreeCaptures.push(m);
                    }
                }
            }
        }
        return possibleFreeCaptures;
    }

    function getValueCaptures(moves) {
        let possibleCaptures = [];
        let maxValue = 0;
        for(let i = 0; i < moves.length; i++) {
            let m = moves[i];
            if(m.captured) {
                let value = pieceCost[m.captured] - pieceCost[m.piece];
                if(value > 0) {
                    if(value > maxValue) {
                        move = m;
                        possibleCaptures = [m];
                        maxValue = value;
                    } else if(value === maxValue) {
                        possibleCaptures.push(m);
                    }
                } 
            }
        }
        return possibleCaptures;
    }

    function getSafeMoves(moves) {
        let possibleSafeMoves = [];
        for(let i = 0; i < moves.length; i++) {
            let m = moves[i];
            window.game.move(m);
            let newPossibleMoves = window.game.moves({verbose:true});
            let isSafe = true;
            for(let k = 0; k < newPossibleMoves.length; k++) {
                let m2 = newPossibleMoves[k];
                if(m2.captured && m2.to === m.to) {
                    isSafe = false;
                    break;
                }
            }
            
            window.game.undo(); //Restore previous position
            
            if(!isSafe) {
                continue;
            } else {
                possibleSafeMoves.push(m);
            }
        }
        return possibleSafeMoves;
    }

    function getMostValuedAttackedSquare() {
        switchSide();
        let newPossibleMoves = window.game.moves({verbose:true});
        let freeCap = getFreeCaptures(newPossibleMoves);
        let valCap = getValueCaptures(newPossibleMoves);
        for(let i = 0; i < freeCap.length; i++) {
            let val = pieceCost[freeCap[i].captured];
            freeCap[i].val = val;
        }
        for(let i = 0; i < valCap.length; i++) {
            let val = pieceCost[valCap[i].captured] - pieceCost[valCap[i].piece];
            valCap[i].val = val;
        }

        let mostValSquare = null;
        let maxValue = 0;
        let allMoves = freeCap.concat(valCap);

        for(let i = 0; i < allMoves.length; i++) {
            if(allMoves[i].val > maxValue) {
                mostValSquare = allMoves[i].to;
                maxValue = allMoves[i].val;
            }
        }

        switchSide();
        return mostValSquare;
    }

    function switchSide() {
        if(window.game.turn() === "w") {
            window.game.load(window.game.fen().replace(" w ", " b "));
        } else {
            window.game.load(window.game.fen().replace(" b ", " w "));
        }
    }
</script>
</html>