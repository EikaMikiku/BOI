<!DOCTYPE html>
<html>
<head>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>BOI (Bunch Of Ifs)</title>
	<link rel="stylesheet" type="text/css" href="css/chessboard-0.3.0.min.css">
	<script type="text/javascript" src="js/chess.min.js"></script>
	<script type="text/javascript" src="js/jquery-3.3.1.min.js"></script>
	<script type="text/javascript" src="js/chessboard-0.3.0.min.js"></script>
	<style type="text/css">
		body {
			margin: 0;
			padding: 0;
			display: flex;
			justify-content: center;
		}
		#board {
			display: flex;
			align-items: center;
			margin: 0;
			height: 100vh;
			width: 500px;
		}
		.white-1e1d7 {
			background: #ffffff;
		}
		.black-3c85d {
			background: #d2d2d2;
		}
	</style>
</head>
<body>
	<div id="board"></div>
</body>
<script type="text/javascript">
	let pieceCost = {
		p: 1, n: 3, b: 3, r: 5, q: 9, k: Infinity
	};
	let pieceActivityWeights = {
		p: 0.01, n: 0.05, b: 0.05, r: 0.05, q: 0.01, k: 0.01
	};

	let boardConfig = {
		draggable: true,
		showNotation: false,
		position: "start",
		moveSpeed: "fast",
		pieceTheme: "img/chesspieces/alpha/{piece}.png",
		onDrop: function(from, to) {
			let move = game.move({
				from: from,
				to: to,
				promotion: "q"
			});
			if (move === null) {
				return "snapback";
			}
			setTimeout(MakePseudoRandomMove, 250);
		}
	};

	window.gameSpeed = 250;
	window.newGameDelay = 1;
	window.board = ChessBoard("board", boardConfig);
	window.game = new Chess();

	function analyseMove(move, depth) {
		let value = move.value;
		let fen = window.game.fen();

		//Apply position value to the move
		value -= getPositionValue();
		window.game.move(move.move);
		switchSide();
		value += getPositionValue();
		window.game.load(fen); //Reset the game

		if(depth <= 0) {
			return value;
		} else {
			window.game.move(move.move);
			var enemyBestMove = findBestMove(depth - 1);
			window.game.load(fen); //Reset the game
			return value - enemyBestMove.value;
		}
	}

	function findBestMove(depth) {
		let possibleMoves = window.game.moves({verbose:true});

		//Always do the checkmate immediatly
		for(let i = 0; i < possibleMoves.length; i++) {
			if(possibleMoves[i].san.indexOf("#") >= 0) {
				return {
					move: possibleMoves[i],
					value: Infinity
				};
			}
		}

		//Find all candidate moves, make sure they are unique
		let _uniqifier = {};
		let candidateMoves = [];
		let freeCaptures = getFreeCaptures(possibleMoves);
		let valueCaptures = getValueCaptures(possibleMoves);
		let safeMoves = getSafeMoves(possibleMoves);
		for(let i = 0; i < freeCaptures.length; i++) {
			if(!_uniqifier[freeCaptures[i].move.san]) {
				_uniqifier[freeCaptures[i].move.san] = true;
				candidateMoves.push(freeCaptures[i]);
			}
		}
		for(let i = 0; i < valueCaptures.length; i++) {
			if(!_uniqifier[valueCaptures[i].move.san]) {
				_uniqifier[valueCaptures[i].move.san] = true;
				candidateMoves.push(valueCaptures[i]);
			}
		}
		for(let i = 0; i < safeMoves.length; i++) {
			if(!_uniqifier[safeMoves[i].move.san]) {
				_uniqifier[safeMoves[i].move.san] = true;
				candidateMoves.push(safeMoves[i]);
			}
		}

		//Analyse candidate moves
		let bestMoves = [];
		let bestValue = -Infinity;
		for(let i = 0; i < candidateMoves.length; i++) {
			var value = analyseMove(candidateMoves[i], depth);
			if(value > bestValue) {
				bestValue = value;
				bestMoves = [candidateMoves[i].move];
			} else if(value === bestValue) {
				bestMoves.push(candidateMoves[i].move);
			}
		}

		//Give a random best move
		return {
			move: bestMoves[Math.floor(Math.random() * bestMoves.length)],
			value: bestValue
		};
	}

	function MakePseudoRandomMove() {
		let possibleMoves = window.game.moves({verbose:true});
		if(window.game.game_over() || window.game.in_draw() || possibleMoves.length === 0) {
			return setTimeout(function() {
				window.game.reset();
				window.board.position(window.game.fen());
			}, window.newGameDelay * 1000);
		}

		let moveData = findBestMove(1);
		window.game.move(moveData.move);
		window.board.position(window.game.fen());
	}

	function getFreeCaptures(moves) {
		let possibleFreeCaptures = [];
		for(let i = 0; i < moves.length; i++) {
			let m = moves[i];
			if(m.captured) {
				let isNotFree = false;
				//Test out capture
				window.game.move(m);
				//Check if are re-captures on that square
				let newPossibleMoves = window.game.moves({verbose:true});
				for(let k = 0; k < newPossibleMoves.length; k++) {
					let m2 = newPossibleMoves[k];
					if(m2.captured && m2.to === m.to) {
						isNotFree = true;
						break;
					}
				}
				
				window.game.undo(); //Restore previous position

				if(isNotFree) {
					continue; //Try next capture
				} else {
					possibleFreeCaptures = [{
						move: m,
						value: pieceCost[m.captured]
					}];
				}
			}
		}
		return possibleFreeCaptures;
	}

	function getValueCaptures(moves) {
		let possibleCaptures = [];
		for(let i = 0; i < moves.length; i++) {
			let m = moves[i];
			if(m.captured) {
				let value = pieceCost[m.captured] - pieceCost[m.piece];
				if(value >= 0) {
					possibleCaptures.push({
						move: m,
						value: value
					})
				} 
			}
		}
		return possibleCaptures;
	}

	function getSafeMoves(moves) {
		let possibleSafeMoves = [];
		for(let i = 0; i < moves.length; i++) {
			let m = moves[i];
			window.game.move(m);
			let newPossibleMoves = window.game.moves({verbose:true});
			let isSafe = true;
			for(let k = 0; k < newPossibleMoves.length; k++) {
				let m2 = newPossibleMoves[k];
				if(m2.captured && m2.to === m.to) {
					isSafe = false;
					break;
				}
			}
			
			window.game.undo(); //Restore previous position
			
			if(!isSafe) {
				continue;
			} else {
				possibleSafeMoves.push({
					move: m,
					value: 0
				});
			}
		}
		return possibleSafeMoves;
	}

	function getPositionValue() {
		let moves = window.game.moves({verbose:true});
		let sum = 0;
		for(let i = 0; i < moves.length; i++) {
			let m = moves[i];
			sum += pieceActivityWeights[m.piece];
		}
		return sum;
	}

	function getMostValuedAttackedSquare() {
		let fen = window.game.fen();
		switchSide();
		let newPossibleMoves = window.game.moves({verbose:true});
		let freeCap = getFreeCaptures(newPossibleMoves);
		let valCap = getValueCaptures(newPossibleMoves);
		for(let i = 0; i < freeCap.length; i++) {
			let val = pieceCost[freeCap[i].captured];
			freeCap[i].val = val;
		}
		for(let i = 0; i < valCap.length; i++) {
			let val = pieceCost[valCap[i].captured] - pieceCost[valCap[i].piece];
			valCap[i].val = val;
		}

		let mostValSquare = null;
		let maxValue = 0;
		let allMoves = freeCap.concat(valCap);

		for(let i = 0; i < allMoves.length; i++) {
			if(allMoves[i].val > maxValue) {
				mostValSquare = allMoves[i].to;
				maxValue = allMoves[i].val;
			}
		}

		window.board.load(fen);
		return mostValSquare;
	}

	function switchSide() {
		//Make sure to save fen and load it to switch back
		//This switch removes enpassant
		if(window.game.turn() === "w") {
			window.game.load(
				window.game.fen()
				.replace(" w ", " b ")
				.replace(/\s[a-h][36]\s/, " - ")
			);
		} else {
			window.game.load(
				window.game.fen()
				.replace(" b ", " w ")
				.replace(/\s[a-h][36]\s/, " - ")
			);
		}
	}
</script>
</html>